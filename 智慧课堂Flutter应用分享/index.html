<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    
    
      
      
        
      
    
    <div class="bg-lines">
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
    </div>
    <nav class="nav from-post">
  <div class="bg"></div>
  <a class="nav-title" href="/">
    HEY!HENRY
  </a>
  <ul class="nav-links">
    <li>
      <a class="nav-link bold" href="/archives/">
        All articles
        <span class="nav-link-number">7</span>
      </a>
    </li>
    
      <li>
        <a class="nav-link" href="/tags/React/">
          React
          <span class="nav-link-number">
            2
          </span>
        </a>
      </li>
    
      <li>
        <a class="nav-link" href="/tags/Basic/">
          Basic
          <span class="nav-link-number">
            1
          </span>
        </a>
      </li>
    
      <li>
        <a class="nav-link" href="/tags/Server/">
          Server
          <span class="nav-link-number">
            2
          </span>
        </a>
      </li>
    
      <li>
        <a class="nav-link" href="/tags/Cross-Platform/">
          Cross-Platform
          <span class="nav-link-number">
            2
          </span>
        </a>
      </li>
    
  </ul>
  <a class="leave-btn" href="http://hong-yu.wang" target="_blank" rel="noopener">ABOUT ME</a>
</nav>

<nav class="nav-mobile">
  <div class="top-bar">
    <a class="logo" href="/" ></a>
    <ul class="btns">
      <li class="btn" data-type="tag">
        <p class="text">ARTICLES</p>
        <p class="icon icon-book"></p>
      </li>
    </ul>
  </div>
  <div class="list tag-list">
    <div></div>
    <div class="list-main">
      <ul>
        <li>
          <a class="link" href="/archives/">
            All articles
          </a>
        </li>
        
          <li>
            <a class="link" href="/tags/React/">
              React
            </a>
          </li>
        
          <li>
            <a class="link" href="/tags/Basic/">
              Basic
            </a>
          </li>
        
          <li>
            <a class="link" href="/tags/Server/">
              Server
            </a>
          </li>
        
          <li>
            <a class="link" href="/tags/Cross-Platform/">
              Cross-Platform
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>
    <div class="body from-post">
      
  
    <div class="main">

  

<section class="menu">
  <header class="header">
    <h1 class="title">
      Cross-Platform
      <span class="number">2</span>
    </h1>
  </header>
  <section class="list">
    
      <article class="item ">
        <a href="/跨端方案/">
          <p class="item-info">2019-12-16 15:32</p>
          <p class="item-title">跨端方案</p>
        </a>
      </article>
    
      <article class="item current">
        <a href="/智慧课堂Flutter应用分享/">
          <p class="item-info">2020-01-03 17:37</p>
          <p class="item-title">智慧课堂Flutter应用分享</p>
        </a>
      </article>
    
  </section>
</section>
  <section class="article">
  <p class="info">2020-01-03 17:37</p>
  <h1 class="title">智慧课堂Flutter应用分享</h1>
  <p class="summary"></p>
  <div class="main-content">
    <h1 id="0-项目概述"><a href="#0-项目概述" class="headerlink" title="0 项目概述"></a>0 项目概述</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Flutter是2018年新兴的跨端应用开发框架，基于智慧课堂移动端产品原型，开发Flutter demo，扩展移动APP开发能力。</p>
<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="evernotecid://35F614F3-51E7-44D8-826E-275776B5F114/appyinxiangcom/3664339/ENResource/p722" alt="8c1985a5a6ce029961d24f0344c597fb.png"></p>
<h1 id="1-认识Flutter"><a href="#1-认识Flutter" class="headerlink" title="1 认识Flutter"></a>1 认识Flutter</h1><h2 id="跨端技术对比"><a href="#跨端技术对比" class="headerlink" title="跨端技术对比"></a>跨端技术对比</h2><table>
<thead>
<tr>
<th>技术类型</th>
<th>UI渲染方式</th>
<th>性能</th>
<th>开发效率</th>
<th>动态化</th>
<th>框架代表</th>
</tr>
</thead>
<tbody><tr>
<td>H5+原生</td>
<td>WebView渲染</td>
<td>一般</td>
<td>高</td>
<td>✔️</td>
<td>Cordova、Ionic</td>
</tr>
<tr>
<td>JavaScript+原生渲染</td>
<td>原生控件渲染</td>
<td>好</td>
<td>高</td>
<td>✔️</td>
<td>RN、Weex</td>
</tr>
<tr>
<td>自绘UI+原生</td>
<td>调用系统API渲染</td>
<td>好</td>
<td>Flutter高, QT低</td>
<td>默认不支持</td>
<td>QT、Flutter</td>
</tr>
</tbody></table>
<h3 id="H5-原生"><a href="#H5-原生" class="headerlink" title="H5+原生"></a>H5+原生</h3><p>称h5+原生的开发模式为混合开发 ，采用混合模式开发的APP我们称之为混合应用或Hybrid APP ，如果一个应用的大多数功能都是H5实现的话，我们称其为Web APP。</p>
<p><img src="https://user-images.githubusercontent.com/14797054/51163095-8892d100-18d3-11e9-9597-c4fee6371040.png" alt="image"></p>
<ul>
<li>H5：正常的前端web页面开发，生成的是DOM树，通过JsBridge提供的API调用系统功能。</li>
<li>JsBridge：混合框架一般都会在原生代码中预先实现一些访问系统能力的API， 然后暴露给WebView以供JavaScript调用。</li>
<li>WebView：H5页面的容器，同时能连接原生功能给JsBridge接。</li>
</ul>
<h3 id="JavaScript-原生渲染"><a href="#JavaScript-原生渲染" class="headerlink" title="JavaScript+原生渲染"></a>JavaScript+原生渲染</h3><p><img src="https://user-images.githubusercontent.com/14797054/51163101-9183a280-18d3-11e9-95a0-79192d5b4577.png" alt="image"></p>
<p>与混合开发最大的区别就是：混合开发JS生成的仍是DOM，只是给它一个容器；而JS原生渲染产出的则是原生组件树。</p>
<ul>
<li>JS：主要有RN、Weex两种代表，差在语法风格上。JS部分生成虚拟DOM，传递给JSCore。</li>
<li>JSCore：把虚拟DOM编译成原生组件树</li>
</ul>
<h3 id="自绘UI-原生"><a href="#自绘UI-原生" class="headerlink" title="自绘UI+原生"></a>自绘UI+原生</h3><p><img src="https://user-images.githubusercontent.com/14797054/51163107-98aab080-18d3-11e9-910c-a0290f1edd22.png" alt="image"></p>
<p>自绘UI+原生更接近原生开发风格，不同的是统一了开发语言，并通过编译引擎生成两套原生机器码。</p>
<h2 id="Flutter-Dart特点"><a href="#Flutter-Dart特点" class="headerlink" title="Flutter/Dart特点"></a>Flutter/Dart特点</h2><ul>
<li>跨平台自绘引擎：Skia作为其2D渲染引擎</li>
<li>高性能：相比JS的优势<ul>
<li>Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。</li>
<li>Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。</li>
</ul>
</li>
<li>运行时和编译器支持两种模式<ul>
<li>开发JIT：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译</li>
<li>发布AOT：Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能</li>
</ul>
</li>
<li>类型安全，支持静态类型检测</li>
</ul>
<h2 id="Flutter架构"><a href="#Flutter架构" class="headerlink" title="Flutter架构"></a>Flutter架构</h2><p><img src="https://user-images.githubusercontent.com/14797054/51163140-aeb87100-18d3-11e9-8e13-8695dea02eaa.png" alt="image"></p>
<h3 id="Flutter-Framework"><a href="#Flutter-Framework" class="headerlink" title="Flutter Framework"></a>Flutter Framework</h3><p>纯Dart实现的SDK基础库：</p>
<ul>
<li>Fondation、Animation、Painting、Gestures：底层UI库，即dart:ui包。可以对应理解为web中的window对象，提供动画、绘制、手势基础API。</li>
<li>Rendering：基于底层UI实现的布局层，可以理解为React，是Flutter核心。<ul>
<li>维护一个UI树（类似React虚拟DOM）</li>
<li>当UI树变化，计算出变化的部分，更新UI树（类似React diff）</li>
<li>响应元素位置、大小的定义和变换，调用底层UI绘制元素（类似React DOM）</li>
</ul>
</li>
<li>Widget：定义了一些基础组件，其实相当于html元素、小程序标签、React的JSX。我们写Flutter基本就在调这层东西。</li>
<li>Material、Cupertino：在Widget基础上提供的视觉组件库，相当于Antd、ElementUI。</li>
</ul>
<h3 id="Flutter-Engine"><a href="#Flutter-Engine" class="headerlink" title="Flutter Engine"></a>Flutter Engine</h3><p>纯C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 dart:ui库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。</p>
<h1 id="2-Dart语法入门"><a href="#2-Dart语法入门" class="headerlink" title="2 Dart语法入门"></a>2 Dart语法入门</h1><blockquote>
<p>Dart是Flutter唯一开发语言，集合了Java和Javascript的语法风格</p>
</blockquote>
<h2 id="变量与函数"><a href="#变量与函数" class="headerlink" title="变量与函数"></a>变量与函数</h2><p>Dart是一种强类型语言，但又保持对js开发者足够友好，所以声明Dart变量有很多种方式。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>针对两个问题，不同声明方式的限制不同：<br>1、变量的值在何时确定，能否改变<br>2、变量的类型能否改变</p>
<p><img src="http://agroup-bos.cdn.bcebos.com/18ca4753d679c08ef323e8517c18469b00de74ee" alt="图片"><br>说明：</p>
<ul>
<li>声明格式：关键词 类型（可选） 变量名，<code>final List&lt;Widget&gt; children;</code>如果没给类型，自动进行类型推断</li>
<li>这里的dynamic和Object完全一样，因为Dart的一切变量都是Object</li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li>num<ul>
<li>int</li>
<li>double</li>
</ul>
</li>
<li>String</li>
<li>bool</li>
<li>list</li>
<li>map</li>
<li>runes</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNoble</span><span class="hljs-params">(<span class="hljs-keyword">int</span> atomicNumber)</span> </span>&#123;&#125;    <span class="hljs-comment">// 带类型</span><br><span class="hljs-keyword">bool</span> isNoble （<span class="hljs-keyword">int</span> atomicNumber ）=&gt; _nobleGases [ atomicNumber ] ！= null ;    <span class="hljs-comment">// 支持箭头函数</span><br><span class="hljs-function"><span class="hljs-keyword">String</span> <span class="hljs-title">say</span><span class="hljs-params">(<span class="hljs-keyword">String</span> from, <span class="hljs-keyword">String</span> msg, [<span class="hljs-keyword">String</span> device])</span> </span>&#123;&#125;    <span class="hljs-comment">// []可选参数</span><br></code></pre></td></tr></table></figure>

<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="http://agroup-bos.cdn.bcebos.com/978d2c541b35ed627b32d4573c0e28416d230bee" alt="图片"></p>
<h3 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h3><ul>
<li>分支<ul>
<li>if else</li>
<li>switch case</li>
</ul>
</li>
<li>循环<ul>
<li>for</li>
<li>for in</li>
<li>foreach</li>
<li>break</li>
<li>continue</li>
</ul>
</li>
<li>异常<ul>
<li>throw</li>
<li>try catch finally</li>
</ul>
</li>
</ul>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="Future：（相当于Promise）"><a href="#Future：（相当于Promise）" class="headerlink" title="Future：（相当于Promise）"></a>Future：（相当于Promise）</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 相当于new Promise</span><br>Future.delayed(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>),()&#123;<br>   <span class="hljs-keyword">throw</span> AssertionError(<span class="hljs-string">"Error"</span>);<br>&#125;).then((data)&#123;            <span class="hljs-comment">// 相当于then</span><br>   <span class="hljs-built_in">print</span>(data);<br>&#125;).catchError((e)&#123;            <span class="hljs-comment">// 相当于catch</span><br>   <span class="hljs-built_in">print</span>(e);<br>&#125;).whenComplete(()&#123;            <span class="hljs-comment">// 相当于finally</span><br>&#125;);<br><br><span class="hljs-comment">// 相当于Promise.all</span><br>Future.wait([<br>  Future.delayed(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>), () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;<br>  &#125;),<br>  Future.delayed(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">4</span>), () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">" world"</span>;<br>  &#125;)<br>]).then((results)&#123;<br>  <span class="hljs-built_in">print</span>(results[<span class="hljs-number">0</span>]+results[<span class="hljs-number">1</span>]);<br>&#125;).catchError((e)&#123;<br>  <span class="hljs-built_in">print</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h3><p>和JS用法完全一样</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Promise的决议是不可逆的，一旦Resolve或者Reject了，就不会再改变状态。<br>即使是Promise.all或Promise.race也只决议一次。<br>Stream能像all/race一样包裹多个Futrue，不同的是每次Future返回都能触发Stream的状态，更像一个事件派发/收集者。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Stream.fromFutures([<br>  Future.delayed(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>), () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello 1"</span>;<br>  &#125;),<br>  Future.delayed(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>),()&#123;<br>    <span class="hljs-keyword">throw</span> AssertionError(<span class="hljs-string">"Error"</span>);<br>  &#125;),<br>  Future.delayed(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>), () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello 3"</span>;<br>  &#125;)<br>]).listen((data)&#123;<br>   <span class="hljs-built_in">print</span>(data);<br>&#125;, onError: (e)&#123;<br>   <span class="hljs-built_in">print</span>(e.message);<br>&#125;,onDone: ()&#123;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h1 id="3-从智慧课堂Flutter入手"><a href="#3-从智慧课堂Flutter入手" class="headerlink" title="3 从智慧课堂Flutter入手"></a>3 从智慧课堂Flutter入手</h1><blockquote>
<p>从智慧课堂Flutter入手，熟悉Dart语言，了解模块化、包管理、路由、HTTP</p>
</blockquote>
<h2 id="Flutter智慧课堂实例"><a href="#Flutter智慧课堂实例" class="headerlink" title="Flutter智慧课堂实例"></a>Flutter智慧课堂实例</h2><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment"><span class="markdown">/**<br><span class="hljs-bullet"> * </span>@file main.dart<br><span class="hljs-bullet"> * </span>@description 应用入口<br> */</span></span><br><br><span class="hljs-comment">// 引入包（material UI库）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">'./pages/home.dart'</span> <span class="hljs-keyword">as</span> Home;<br><span class="hljs-keyword">import</span> <span class="hljs-string">'./pages/books.dart'</span> <span class="hljs-keyword">as</span> Book;<br><br><span class="hljs-comment">// 应用入口</span><br><span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());<br><br><span class="hljs-comment">// MyApp：根组件，继承StatelessWidget组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-comment">// build方法：Flutter组件必须返回一个build方法，描述该组件如何渲染，通常返回对其他组件的组合，相当于React render方法</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// MaterialApp：material.dart引进来的，初始化App容器</span><br>    <span class="hljs-comment">// Dart的组件调用写法：组件名(属性: 值)的方式，相当于JSX中&lt;组件名 属性=&#123;值&#125; /&gt;</span><br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">'百度智慧课堂'</span>,<br>      theme: ThemeData(<br>        primarySwatch: Colors.green,<br>      ),<br>      <span class="hljs-comment">// home：配置主页面组件</span><br>      home: Home.Page(),<br>      <span class="hljs-comment">// 命名路由</span><br>      routes: &#123;<br>        <span class="hljs-string">'home'</span>: (context) =&gt; Home.Page(),<br>        <span class="hljs-string">'book'</span>: (context) =&gt; Book.Page()<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="组件调用"><a href="#组件调用" class="headerlink" title="组件调用"></a>组件调用</h3><p>Flutter用<br><code>组件名(属性: 值)</code><br>的方式调组件构造函数</p>
<p>在Flutter中，一切都是组件叠起来的，包括样式，所以类CSS的样式属性定义也是这么实现的，比如：<br><img src="evernotecid://35F614F3-51E7-44D8-826E-275776B5F114/appyinxiangcom/3664339/ENResource/p724" alt="e26ab28ce901e3d5fc1e9fa684ec0ba5.png"></p>
<h3 id="StatelessWidget-amp-StatefulWidget"><a href="#StatelessWidget-amp-StatefulWidget" class="headerlink" title="StatelessWidget &amp; StatefulWidget"></a>StatelessWidget &amp; StatefulWidget</h3><p>Flutter把组件基类分为无状态组件和有状态组件，就像React中的一样。</p>
<h4 id="StatelessWidget：无状态组件"><a href="#StatelessWidget：无状态组件" class="headerlink" title="StatelessWidget：无状态组件"></a>StatelessWidget：无状态组件</h4><p>主页home.dart就是一个无状态组件：<br><img src="evernotecid://35F614F3-51E7-44D8-826E-275776B5F114/appyinxiangcom/3664339/ENResource/p723" alt="d9d9a45ef214edb0549e054e13ed3772.png"></p>
<p>StatelessWidget直接定义build函数。</p>
<p><img src="https://user-images.githubusercontent.com/14797054/51301891-a98e2a00-1a6b-11e9-8912-f30c020e98b7.png" alt="image"></p>
<h4 id="StatefulWidget：有状态组件"><a href="#StatefulWidget：有状态组件" class="headerlink" title="StatefulWidget：有状态组件"></a>StatefulWidget：有状态组件</h4><p>StatefulWidget不仅需要定义build，还需要创建State，但State是以类的形式存在的，而build需要state。</p>
<p><img src="https://user-images.githubusercontent.com/14797054/51301902-b27efb80-1a6b-11e9-9026-e65859943e49.png" alt="image"></p>
<p>所以习惯上，StatefulWidget只负责实现构造函数和createState方法定义，state定义和build放到state类实例中。</p>
<h2 id="模块化和包管理"><a href="#模块化和包管理" class="headerlink" title="模块化和包管理"></a>模块化和包管理</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>前面可以看到，Dart以ES6一致的import方式引入依赖包。我们同样可以以这种方式引入自己的模块。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">import</span></span> <span class="hljs-string">'../widgets/common/layout.dart'</span>;<br></code></pre></td></tr></table></figure>

<p>但Dart中没有export，也就是说，在layout.dart中定义的所有class都可以在main.dart中引用到。</p>
<p>这样模块多了难免造成命名冲突，所以Dart也支持这样：</p>
<p><img src="evernotecid://35F614F3-51E7-44D8-826E-275776B5F114/appyinxiangcom/3664339/ENResource/p726" alt="cfac143598a381574b7ce4d23789e45c.png"></p>
<p>还可以导入部分</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 只导入 Layout</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> '../widgets/common/layout.dart’ show Layout;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 导入Layout外其他包</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> '../widgets/common/layout.dart’ hide Layout;</span><br></code></pre></td></tr></table></figure>
<h3 id="pubspec-yaml"><a href="#pubspec-yaml" class="headerlink" title="pubspec.yaml"></a>pubspec.yaml</h3><p>Flutter有一个类似package.json的文件：pubspec.yaml，记录项目信息及依赖包。<br><img src="evernotecid://35F614F3-51E7-44D8-826E-275776B5F114/appyinxiangcom/3664339/ENResource/p727" alt="2ceea2ca5c70fbc520b5d01f6498b49d.png"></p>
<h3 id="包仓库"><a href="#包仓库" class="headerlink" title="包仓库"></a>包仓库</h3><p>Pub（<a href="https://pub.dartlang.org/" target="_blank" rel="noopener">https://pub.dartlang.org/</a> ）是Google官方的Dart Packages仓库，类似于node中的npm仓库。<br>区别在于，Pub不支持install+save的方式，而是需要手动在pubspec里添加依赖，并通过flutter命令或IDE安装。</p>
<p>比如我们需要一个http请求包<br>1、去Pub找到这个：</p>
<p><img src="https://user-images.githubusercontent.com/14797054/51301936-c88cbc00-1a6b-11e9-9d4f-110db05827df.png" alt="image"></p>
<p>2、在pubspec中添加依赖</p>
<p><img src="https://user-images.githubusercontent.com/14797054/51301953-d2aeba80-1a6b-11e9-9283-bbdbe04a419f.png" alt="image"></p>
<p>3、由于flutter正在run，可以看到VScode自动执行了get安装依赖包：</p>
<p><img src="https://user-images.githubusercontent.com/14797054/51301962-d9d5c880-1a6b-11e9-94df-046ec3096130.png" alt="image"></p>
<p>也可以手动执行</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">flutter packages <span class="hljs-keyword">get</span><br></code></pre></td></tr></table></figure>

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><blockquote>
<p>路由(Route)在移动开发中通常指页面（Page），这跟web开发中单页应用的Route概念意义是相同的，Route在Android中通常指一个Activity，在iOS中指一个ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。这和原生开发类似，无论是Android还是iOS，导航管理都会维护一个路由栈，路由入栈(push)操作对应打开一个新页面，路由出栈(pop)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。</p>
</blockquote>
<h3 id="路由示例"><a href="#路由示例" class="headerlink" title="路由示例"></a>路由示例</h3><p>我们在home里加一个链接，onPress绑定到_gotoPage2方法上，方法代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">void _gotoBook() &#123;<br>    MaterialPageRoute<span class="hljs-built_in"> route </span>= MaterialPageRoute(<br>        builder: (context) =&gt; Book.Page()<br>    );<br>    Navigator.push(context, route);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，当我们点击主页的链接，就会跳转到备课资料库:<br><img src="evernotecid://35F614F3-51E7-44D8-826E-275776B5F114/appyinxiangcom/3664339/ENResource/p729" alt="259b9c0fc6168a774f4a5f7b899f9451.png"></p>
<h3 id="MaterialPageRoute"><a href="#MaterialPageRoute" class="headerlink" title="MaterialPageRoute"></a>MaterialPageRoute</h3><p>这是一个路由类，在Material UI库中，继承了基础的PageRoute。</p>
<p>最主要的参数就是builder，传入一个回调函数，返回Route实例中展现的组件。</p>
<h3 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h3><p>路由管理组件，提供接口管理路由状态。</p>
<ul>
<li>push：传入context和PageRoute实例，将路由入栈以跳转到路由上</li>
<li>pop：传入context，最近路由出栈，实现一个goBack</li>
</ul>
<h3 id="命名路由表"><a href="#命名路由表" class="headerlink" title="命名路由表"></a>命名路由表</h3><p>写过小程序的可能熟悉这样一个操作，就是页面都在app入口注册才能跳转。</p>
<p>Flutter也提供这样的机制，不过不是限制路由可用性，而是给路由命名。</p>
<p>Flutter注册路由的位置在MaterialApp中：</p>
<p><img src="evernotecid://35F614F3-51E7-44D8-826E-275776B5F114/appyinxiangcom/3664339/ENResource/p730" alt="bf99e4babcc8fcd94cd85df01facf212.png"></p>
<p>这样在跳转路由时只要：<br><img src="evernotecid://35F614F3-51E7-44D8-826E-275776B5F114/appyinxiangcom/3664339/ENResource/p731" alt="5d75398a7b975717bec555592979961d.png"></p>
<p>这样做的好处很明显，一是给了路由一个统一的管理入口，二是减少了路由跳转的逻辑。<br>但是，这种路由只在App启动时初始化一次，后面没有任何机会添加参数。</p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><h3 id="http库请求和JSON编解码"><a href="#http库请求和JSON编解码" class="headerlink" title="http库请求和JSON编解码"></a>http库请求和JSON编解码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:convert'</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">'package:http/http.dart'</span> <span class="hljs-keyword">as</span> http;<br><br>...<br>http.<span class="hljs-keyword">get</span>(<span class="hljs-string">'https://easy-mock.com/mock/5bfe010f7baf9b6a9fa6e8c1/tsdudy/getdocument'</span>).then((res) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">var</span> <span class="hljs-keyword">data</span> = JSON.decode(res.body);<br>        <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">data</span>[<span class="hljs-string">'data'</span>][<span class="hljs-string">'list'</span>];<br>        setState(() &#123;<br>          bookList = d;<br>        &#125;);<br>        print(bookList);<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        setState(() &#123;<br>          bookList = [];<br>        &#125;);<br>      &#125;<br>    &#125;);<br>...<br></code></pre></td></tr></table></figure>

<h1 id="4-组件选择（遵循web开发习惯）"><a href="#4-组件选择（遵循web开发习惯）" class="headerlink" title="4 组件选择（遵循web开发习惯）"></a>4 组件选择（遵循web开发习惯）</h1><blockquote>
<p>Flutter一切皆用组件实现，元素本身、布局，甚至一句CSS的事都需要组件嵌套。在web中得心应手的实现方式在Flutter很别扭，这里总结下对应的实现方式</p>
</blockquote>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h3 id="一切皆组件"><a href="#一切皆组件" class="headerlink" title="一切皆组件"></a>一切皆组件</h3><p> Flutter一切皆用组件实现，元素本身、布局，甚至一句CSS、一个CSS的值事都需要组件解决。在web中得心应手的实现方式在Flutter很别扭，这里总结下对应的实现方式</p>
<h3 id="组件分类"><a href="#组件分类" class="headerlink" title="组件分类"></a>组件分类</h3><p>1、构造函数，通常是个实际组件</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Text</span><span class="hljs-params">(<span class="hljs-string">'进入'</span>)</span></span><br></code></pre></td></tr></table></figure>
<p>2、对象，通常携带一堆预设值或者生成某种类型值的函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Colors</span>.</span></span>white<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Color</span>.</span></span>from<span class="hljs-constructor">RGBO(27, 178, 121, 1)</span><br></code></pre></td></tr></table></figure>


<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="Colum：纵向流"><a href="#Colum：纵向流" class="headerlink" title="Colum：纵向流"></a>Colum：纵向流</h3><p>web中我们习惯把元素逐个码出来自然向下排布，在Flutter中，我们需要一个纵向布局组件</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">Column(<br><span class="hljs-symbol">    children:</span> <span class="hljs-params">&lt;Widget&gt;</span>[]<br>)<br></code></pre></td></tr></table></figure>
<p>在children里才能加入多个widget向下排布。</p>
<h3 id="SingleChildScrollView：滚动"><a href="#SingleChildScrollView：滚动" class="headerlink" title="SingleChildScrollView：滚动"></a>SingleChildScrollView：滚动</h3><p>如果内容很多，超出屏幕范围呢？web中不需要考虑这个问题，但在Flutter会报错</p>
<p>所以需要一个支持滚动的容器，注意它只有一个child，所以往往要套Colum用</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">SingleChildScrollView(<br><span class="hljs-symbol">    child:</span> <span class="hljs-params">&lt;Widget&gt;</span>,<br>)<br></code></pre></td></tr></table></figure>

<h3 id="Row：带横向Flex布局的块状元素"><a href="#Row：带横向Flex布局的块状元素" class="headerlink" title="Row：带横向Flex布局的块状元素"></a>Row：带横向Flex布局的块状元素</h3><p>web中，如果需要横向布局多个元素，往往通过div，结合float、flex、inline-block等，Flutter中通过Row实现：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><code class="hljs lisp">Row(<br>    <span class="hljs-name">children</span>: &lt;Widget&gt;[<br>        Expanded(<br>            <span class="hljs-name">child</span>: Text('$selectorText'),<br>        ),<br>    ],<br>)<br></code></pre></td></tr></table></figure>
<p>这里有个Expanded，意思就是flex-grow: 1</p>
<h3 id="Container：盒模型"><a href="#Container：盒模型" class="headerlink" title="Container：盒模型"></a>Container：盒模型</h3><p>web元素都是盒模型，可以配padding、margin、border。在Flutter中，大部分组件没这个，需要套一层专门模拟盒模型的组件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Container(</span><br>    <span class="hljs-attr">padding:</span> <span class="hljs-string">EdgeInsets.only(top:</span> <span class="hljs-number">12</span><span class="hljs-string">,</span> <span class="hljs-attr">bottom:</span> <span class="hljs-number">12</span><span class="hljs-string">,</span> <span class="hljs-attr">left:</span> <span class="hljs-number">70</span><span class="hljs-string">,</span> <span class="hljs-attr">right:</span> <span class="hljs-number">70</span><span class="hljs-string">),</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">270</span><span class="hljs-string">,</span><br>    <span class="hljs-attr">child:</span> <span class="hljs-string">&lt;Widget&gt;,</span><br><span class="hljs-string">)</span><br></code></pre></td></tr></table></figure>
<p>这里连padding值都是个组件EdgeInsets。</p>
<h3 id="Center：居中"><a href="#Center：居中" class="headerlink" title="Center：居中"></a>Center：居中</h3><p>web居中方式多种多样，flex、margin auto、text-align……Flutter通过Center实现居中：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">Center(<br><span class="hljs-symbol">    child:</span> <span class="hljs-params">&lt;Widget&gt;</span>,<br>)<br></code></pre></td></tr></table></figure>



<h2 id="元素-amp-样式"><a href="#元素-amp-样式" class="headerlink" title="元素&amp;样式"></a>元素&amp;样式</h2><h3 id="Text：p、span、h"><a href="#Text：p、span、h" class="headerlink" title="Text：p、span、h"></a>Text：p、span、h</h3><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Text</span>(<span class="hljs-string">'啊啊啊啊啊'</span>, <span class="hljs-attribute">style</span>: TextStyle(<br>    <span class="hljs-attribute">fontWeight</span>: FontWeight.bold,<br>    <span class="hljs-attribute">color</span>: Colors.white,<br>    <span class="hljs-attribute">fontSize</span>: <span class="hljs-number">20</span><br>),)<br></code></pre></td></tr></table></figure>
<p>TextStyle：Text组件的样式组件。<br>FontWeight：font-weight预设值组件。<br>Colors：一个有很多预设颜色的组件。</p>
<h3 id="Image：img"><a href="#Image：img" class="headerlink" title="Image：img"></a>Image：img</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Image</span>.</span></span>network('https:<span class="hljs-comment">//wkstatic.bdimg.com/8ff3891.png')</span><br></code></pre></td></tr></table></figure>

<h3 id="RaisedButton-IconButton：button"><a href="#RaisedButton-IconButton：button" class="headerlink" title="RaisedButton / IconButton：button"></a>RaisedButton / IconButton：button</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">RaisedButton(</span><br>    <span class="hljs-attr">child:</span> <span class="hljs-string">Text('进入'),</span><br>    <span class="hljs-attr">color:</span> <span class="hljs-string">Color.fromRGBO(27,</span> <span class="hljs-number">178</span><span class="hljs-string">,</span> <span class="hljs-number">121</span><span class="hljs-string">,</span> <span class="hljs-number">1</span><span class="hljs-string">),</span><br>    <span class="hljs-attr">padding:</span> <span class="hljs-string">EdgeInsets.only(top:</span> <span class="hljs-number">12</span><span class="hljs-string">,</span> <span class="hljs-attr">bottom:</span> <span class="hljs-number">12</span><span class="hljs-string">,</span> <span class="hljs-attr">left:</span> <span class="hljs-number">70</span><span class="hljs-string">,</span> <span class="hljs-attr">right:</span> <span class="hljs-number">70</span><span class="hljs-string">),</span><br>    <span class="hljs-attr">onPressed:</span> <span class="hljs-string">()</span> <span class="hljs-string">&#123;</span><br>        <span class="hljs-string">Navigator.pushNamed(context,</span> <span class="hljs-string">'home'</span><span class="hljs-string">);</span><br>    <span class="hljs-string">&#125;,</span><br><span class="hljs-string">)</span><br></code></pre></td></tr></table></figure>
<p>Color：另外一个做颜色的组件，主要是RGB的自定义色号。<br>EdgeInsets：内侧布局（padding）样式组件，有多种方法定padding。<br>不是所有的组件都能Press，只有Button之类的有Press事件。</p>
<h3 id="FlatButton：a"><a href="#FlatButton：a" class="headerlink" title="FlatButton：a"></a>FlatButton：a</h3><pre><code>FlatButton(
                            child: Container(
                              width: 1000,
                              padding: EdgeInsets.only(left: 30),
                              child: Text(unit[&apos;children&apos;][i]),
                            ),
                            onPressed: () {
                              setState(() {
                                lessonSelected = unit[&apos;children&apos;][i];
                                lessonOpen = false;
                                _listBook();
                              });
                            },
                          ),</code></pre><h3 id="Icon：图标"><a href="#Icon：图标" class="headerlink" title="Icon：图标"></a>Icon：图标</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Icon</span><span class="hljs-params">(Icons.arrow_drop_up)</span></span><br></code></pre></td></tr></table></figure>

<p>Icons是Flutter的图标库</p>
<h1 id="5-组件语法（对照React）"><a href="#5-组件语法（对照React）" class="headerlink" title="5 组件语法（对照React）"></a>5 组件语法（对照React）</h1><h2 id="综述-1"><a href="#综述-1" class="headerlink" title="综述"></a>综述</h2><p>总体来说，Dart语法对js开发者还是很友好的。本文在模版语法上，做一个React和Dart对照。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>initState : 相当于componentDidMount。初始化widget的时候调用，只会调用一次。 </li>
<li>build : 相当于render。初始化之后开始绘制界面，当setState触发的时候会再次被调用 </li>
<li>didUpdateWidget : 相当于componentWillUpdate，当触发setState时，会被调用 </li>
<li>dispose : 相当于componentWillUnmount，页面销毁的时候调用</li>
</ul>
<p>如图，在build中返回组件实例，在initState请求接口获取数据<br><img src="http://agroup-bos.cdn.bcebos.com/f4a1e9bb1bfec318c8ba2c5cde6ded8ecf5e418d" alt="图片"></p>
<h2 id="state管理"><a href="#state管理" class="headerlink" title="state管理"></a>state管理</h2><p>在React组件中，我们维护一组state，通过改变state映射视图变化。Flutter的StatefulWidget也提供类似能力。</p>
<p>首先声明一个StatefulWidget并绑定state。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>    _PageState createState() =&gt; _PageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State&lt;Page&gt;</span> </span>&#123;<br>    bool selectorOpen = <span class="hljs-literal">false</span>;<br>    void _listBooks() &#123;&#125;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="state初始化"><a href="#state初始化" class="headerlink" title="state初始化"></a>state初始化</h3><p>定义state及初始赋值。</p>
<p>React写法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    constructor(props) &#123;<br>        <span class="hljs-keyword">super</span>(props);<br>        <span class="hljs-keyword">this</span>.state = &#123;<br>            selectorOpen: <span class="hljs-literal">false</span>;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Flutter写法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State&lt;Page&gt;</span> </span>&#123;<br>    bool selectorOpen = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>React需要在组件构造函数中定义object类型的state属性，并把一个state作为key。Flutter直接定义到组件对应的State类属性上。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>更新state，映射视图变化。这里Flutter底层做了一套类似React diff的优化。</p>
<p>React写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.setState</span>(&#123;<br>    <span class="hljs-attribute">selectorOpen</span>: true<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>Flutter</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">setState(() &#123;<br>    selectorOpen = true<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>React以key-value的形式更新state，Flutter用更直观的赋值操作，包裹在setState方法内。</p>
<h2 id="模版逻辑语法"><a href="#模版逻辑语法" class="headerlink" title="模版逻辑语法"></a>模版逻辑语法</h2><h3 id="获取state值"><a href="#获取state值" class="headerlink" title="获取state值"></a>获取state值</h3><p>比如把state值作为string输出。</p>
<p>React</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf"><span class="hljs-variable">&lt;p&gt;</span>教材: &#123;this.<span class="hljs-keyword">state</span>.selectorOpen&#125;&lt;/p&gt;<br>// 或者<br><span class="hljs-variable">&lt;p&gt;</span>&#123;`教材: $&#123;this.<span class="hljs-keyword">state</span>.selectorOpen&#125;`&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure>

<p>Flutter</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Text</span><span class="hljs-params">(<span class="hljs-string">'教材: $selectorText'</span>)</span></span><br></code></pre></td></tr></table></figure>

<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>React：JSX中我们习惯用&amp;&amp;或者三目运算做if</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">selectorOpen &amp;&amp; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><br>selectorOpen ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span> : <span class="hljs-string">''</span><br></code></pre></td></tr></table></figure>

<p>Flutter：由于Dart是强类型的，不存在&amp;&amp;这种hack用法</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">selectorOpen ？<span class="hljs-built_in">Text</span>(<span class="hljs-string">'学段’) : Text('</span><span class="hljs-string">')</span><br></code></pre></td></tr></table></figure>


<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>React</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">list.<span class="hljs-keyword">map</span>(<span class="hljs-type">item</span> =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="xquery">&#123;<span class="hljs-type">item</span>&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>)<br></code></pre></td></tr></table></figure>

<p>Flutter</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">list</span>.map((item) =&gt; <span class="hljs-constructor">Text(<span class="hljs-params">item</span>)</span>).<span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span><br></code></pre></td></tr></table></figure>

<p>map用法几乎完全一致，注意最后要toList一下，不然类型不对。</p>

  </div>
</section>

  




    </div>
  </div>
</body>
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="/js/script.js"></script>

</html>