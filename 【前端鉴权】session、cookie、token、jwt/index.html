<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    
    
      
      
        
      
    
    <div class="bg-lines">
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
      <div class="bg-lines-item"></div>
    </div>
    <nav class="nav from-post">
  <div class="bg"></div>
  <a class="nav-title" href="/">
    HEY!HENRY
  </a>
  <ul class="nav-links">
    <li>
      <a class="nav-link bold" href="/archives/">
        All articles
        <span class="nav-link-number">7</span>
      </a>
    </li>
    
      <li>
        <a class="nav-link" href="/tags/React/">
          React
          <span class="nav-link-number">
            2
          </span>
        </a>
      </li>
    
      <li>
        <a class="nav-link" href="/tags/Basic/">
          Basic
          <span class="nav-link-number">
            1
          </span>
        </a>
      </li>
    
      <li>
        <a class="nav-link" href="/tags/Server/">
          Server
          <span class="nav-link-number">
            2
          </span>
        </a>
      </li>
    
      <li>
        <a class="nav-link" href="/tags/Cross-Platform/">
          Cross-Platform
          <span class="nav-link-number">
            2
          </span>
        </a>
      </li>
    
  </ul>
  <a class="leave-btn" href="http://hong-yu.wang" target="_blank" rel="noopener">ABOUT ME</a>
</nav>

<nav class="nav-mobile">
  <div class="top-bar">
    <a class="logo" href="/" ></a>
    <ul class="btns">
      <li class="btn" data-type="tag">
        <p class="text">ARTICLES</p>
        <p class="icon icon-book"></p>
      </li>
    </ul>
  </div>
  <div class="list tag-list">
    <div></div>
    <div class="list-main">
      <ul>
        <li>
          <a class="link" href="/archives/">
            All articles
          </a>
        </li>
        
          <li>
            <a class="link" href="/tags/React/">
              React
            </a>
          </li>
        
          <li>
            <a class="link" href="/tags/Basic/">
              Basic
            </a>
          </li>
        
          <li>
            <a class="link" href="/tags/Server/">
              Server
            </a>
          </li>
        
          <li>
            <a class="link" href="/tags/Cross-Platform/">
              Cross-Platform
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>
    <div class="body from-post">
      
  
    <div class="main">

  

<section class="menu">
  <header class="header">
    <h1 class="title">
      Server
      <span class="number">2</span>
    </h1>
  </header>
  <section class="list">
    
      <article class="item ">
        <a href="/从主页搭建看nginx常用配置/">
          <p class="item-info">2020-01-03 16:11</p>
          <p class="item-title">从主页搭建看nginx常用配置</p>
        </a>
      </article>
    
      <article class="item current">
        <a href="/【前端鉴权】session、cookie、token、jwt/">
          <p class="item-info">2020-01-03 18:15</p>
          <p class="item-title">【前端鉴权】session、cookie、token、jwt</p>
        </a>
      </article>
    
  </section>
</section>
  <section class="article">
  <p class="info">2020-01-03 18:15</p>
  <h1 class="title">【前端鉴权】session、cookie、token、jwt</h1>
  <p class="summary"></p>
  <div class="main-content">
    <h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><h3 id="鉴权要解决的问题"><a href="#鉴权要解决的问题" class="headerlink" title="鉴权要解决的问题"></a>鉴权要解决的问题</h3><h4 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h4><p>当一个用户进行登录操作，通常会访问数据库校验账号、密码等信息，并获得用户名、角色等信息。</p>
<h4 id="HTTP的无状态性"><a href="#HTTP的无状态性" class="headerlink" title="HTTP的无状态性"></a>HTTP的无状态性</h4><p>然而HTTP是无状态的，即使用户登录过，接下来的HTTP请求也是独立存在的，其一不知道用户是否登录过，其二不知道用户数据。</p>
<h4 id="鉴权要解决的问题-1"><a href="#鉴权要解决的问题-1" class="headerlink" title="鉴权要解决的问题"></a>鉴权要解决的问题</h4><p>鉴权就是要通过某种方式，使用户在登录一次后，在后续某段时间内发起请求时，服务器能识别用户的登录状态，并能获取用户数据。</p>
<h4 id="鉴权思路"><a href="#鉴权思路" class="headerlink" title="鉴权思路"></a>鉴权思路</h4><p>很显然，客户端需要保存某种凭证，以供服务器验证和获取数据。</p>
<h3 id="cookie-session、token鉴权方式对比"><a href="#cookie-session、token鉴权方式对比" class="headerlink" title="cookie-session、token鉴权方式对比"></a>cookie-session、token鉴权方式对比</h3><table>
<thead>
<tr>
<th>方式</th>
<th>客户端凭证存储</th>
<th>服务端存储</th>
<th>解决方案</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>cookie-session</td>
<td>cookie</td>
<td>redis/内存</td>
<td>express-session</td>
<td>web系统</td>
</tr>
<tr>
<td>token</td>
<td>cookie/local storage/param等</td>
<td>-</td>
<td>cookie-session/JWT</td>
<td>web/app等</td>
</tr>
</tbody></table>
<h2 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session-cookie"></a>session-cookie</h2><p>在一些web系统中，通过cookie和session结合的方式认证，称为session-cookie。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie是一种存储在浏览器端的数据，有一定的有效期和有效域。<br>服务端通过set-cookie头通知浏览器添加一条cookie记录，浏览器在指定有效期内向指定域发起HTTP请求时则会把记录携带在HTTP头中。<br>cookie使服务器具备对客户端标记的能力，从而管理HTTP会话状态。</p>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>session是一个抽象的概念，可以理解为某一客户端在一系列同服务器的会话中，服务端记录该客户端对应会话状态的机制。<br>session实体通常包括：一个标记客户端唯一性的id、一份id对应的会话状态数据。</p>
<h3 id="session-cookie原理"><a href="#session-cookie原理" class="headerlink" title="session-cookie原理"></a>session-cookie原理</h3><p><img src="http://static.chiyuanyuan.com/91C5B273-BD8B-4D8A-AF13-906FCFCE94CD.png" alt=""></p>
<h4 id="登录阶段"><a href="#登录阶段" class="headerlink" title="登录阶段"></a>登录阶段</h4><p>用户登录，服务器验证账号密码后，获取用户信息，并生成一个session_id，这个id是唯一的，通常基于密钥、随机数、时间戳等计算出来。<br>算出session_id后，服务器要把session_id发给浏览器，即通过set-Cookie头写到cookie中。<br>在服务器这端，也要存session_id来记录已登录的用户，一般存储在内存或Redis中。   </p>
<h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><p>当浏览器又发起后续请求，会在请求头的cookie字段中携带session_id。<br>服务器拿到session_id，去服务端存储session的地方查询记录。如有记录，则鉴权通过，正常执行业务逻辑；如无记录或记录过期，则鉴权失败。   </p>
<h3 id="session-cookie实现：express-session"><a href="#session-cookie实现：express-session" class="headerlink" title="session-cookie实现：express-session"></a>session-cookie实现：express-session</h3><p>express应用中，可通过express-session库简单实现cookie-session。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);<br><span class="hljs-keyword">var</span> app = express();<br><span class="hljs-keyword">var</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express-session'</span>);<br><span class="hljs-keyword">var</span> bodyparser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'body-parser'</span>);<br>app.use(bodyparser.urlencoded());<br>app.use(session(&#123;<br>    secret: <span class="hljs-string">'why'</span>,<br>    resave: <span class="hljs-literal">true</span>,<br>    saveUninitialized: <span class="hljs-literal">false</span><br>&#125;));<br>app.post(<span class="hljs-string">'/login'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (req.body.userid === <span class="hljs-string">'a'</span> &amp;&amp; req.body.pwd === <span class="hljs-string">'why'</span>) &#123;<br>        req.session.userid = req.body.userid;<br>        res.send(<span class="hljs-string">'login success'</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.send(<span class="hljs-string">'login fail'</span>);<br>    &#125;<br>&#125;);<br>app.get(<span class="hljs-string">'/getuserid'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (req.session &amp;&amp; req.session.userid) &#123;<br>        res.send(req.session.userid);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.send(<span class="hljs-string">'denied'</span>);<br>    &#125;<br>&#125;);<br>app.get(<span class="hljs-string">'/logout'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    req.session.destroy(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        res.send(<span class="hljs-string">'logout'</span>);<br>    &#125;);<br>&#125;);<br>app.listen(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure>
<p>可以看到，express-cookie在浏览器种了一个cookie：<br><img src="http://static.chiyuanyuan.com/DFCBB7EA-3485-4C70-B6CC-E0F471A83942.png" alt=""></p>
<h4 id="express-session做的工作"><a href="#express-session做的工作" class="headerlink" title="express-session做的工作"></a>express-session做的工作</h4><p>从上面的代码可见，通过express-session，我们只要关注中间件的配置和req.session就能方便的控制cookie-session了。</p>
<p><img src="http://static.chiyuanyuan.com/6BA147A5-F21C-4CFF-9FAD-605475110F71.png" alt=""></p>
<p>express-session主要实现了以下工作：</p>
<ul>
<li>封装了对cookie的读写操作，并提供配置项配置字段、加密方式、过期时间等。</li>
<li>封装了对session的存取操作，并提供配置项配置session存储方式（内存/redis）、存储规则等。</li>
<li>给req提供了session属性，控制属性的set/get并响应到cookie和session存取上，并给req.session提供了一些方法。</li>
</ul>
<h3 id="cookie-session问题"><a href="#cookie-session问题" class="headerlink" title="cookie-session问题"></a>cookie-session问题</h3><p>cookie-session解决了HTTP无状态，但仍存在几个问题。</p>
<h4 id="客户端角度"><a href="#客户端角度" class="headerlink" title="客户端角度"></a>客户端角度</h4><p>cookie-session要利用客户端的cookie，那么问题来了：</p>
<ul>
<li>客户端类型被局限在浏览器了，在没有cookie的客户端上没法工作。</li>
<li>容易到CSRF攻击。</li>
<li>cookie增加了HTTP请求的体积，而且存在浪费。比如同一个域名下只有几个接口需要鉴权，但cookie会被带到该域名所有的请求中。</li>
</ul>
<h4 id="服务端角度"><a href="#服务端角度" class="headerlink" title="服务端角度"></a>服务端角度</h4><p>在服务端，需要保存session，那么问题来了：</p>
<ul>
<li>增加了服务端开销。无论放在内存还是Redis，服务器的内存压力都会随请求数增加而增长。</li>
<li>服务器扩展成本高。如果请求打在负载均衡集群上，集群机器间就必须同步session。针对这个有两个办法：一是让一个客户端固定请求同一台机器，但这增加了负载风险；二是将session存储在额外的机器上，但如果存session的机器挂了，整个集群session都完了。</li>
</ul>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>前面提到cookie-session的问题，主要集中在两个方面：</p>
<ul>
<li>客户端存cookie，限制了客户端的范围</li>
<li>服务端存session，增加了服务器开销，限制了服务器的扩展性</li>
</ul>
<p>token的出现解决了这两方面的问题：</p>
<ul>
<li>客户端存储凭证不限于cookie</li>
<li>避免服务端存储</li>
</ul>
<p>关键点：把session以某种形式存储在凭证中，这样凭证就不仅是一个用户会话的标识了，还包含了会话中的数据。</p>
<h3 id="token原理"><a href="#token原理" class="headerlink" title="token原理"></a>token原理</h3><p><img src="http://static.chiyuanyuan.com/4AADE9C7-B530-428F-A497-A9AC157FE954.png" alt=""></p>
<h4 id="登录阶段-1"><a href="#登录阶段-1" class="headerlink" title="登录阶段"></a>登录阶段</h4><p>用户登录，校验账号密码，获得用户信息。然后以会话数据为基础，通常还要混入密钥、时间戳、签名等，计算出一个token字符串。<br>然后将计算好的token返回给客户端，可能通过set-Cookie，也可能直接作为接口返回。在web的登录场景下，token仍多存在cookie。<br>客户端收到token后会保存起来，可以是cookie、localstorage或者其他方式。</p>
<h4 id="验证阶段-1"><a href="#验证阶段-1" class="headerlink" title="验证阶段"></a>验证阶段</h4><p>客户端再次请求需要带上token，可能是cookie，也可以作为调用参数。<br>服务端对token进行解析，验证token的有效性，并获取其中的数据。</p>
<h3 id="token实现之一：cookie-session库"><a href="#token实现之一：cookie-session库" class="headerlink" title="token实现之一：cookie-session库"></a>token实现之一：cookie-session库</h3><p>express应用中有cookie-session库：<a href="https://www.npmjs.com/package/cookie-session。" target="_blank" rel="noopener">https://www.npmjs.com/package/cookie-session。</a><br>为什么还叫cookie-session，我的理解是：以Token的方式，利用cookie，实现了用户登录会话效果。<br>库的解释如下：</p>
<blockquote>
<p>A user session can be stored in two main ways with cookies: on the server or on the client. This module stores the session data on the client within a cookie, while a module like express-session stores only a session identifier on the client within a cookie and stores the session data on the server, typically in a database.</p>
</blockquote>
<blockquote>
<p>借助cookie，用户会话有两种存储方式：服务端或客户端。本模块把会话数据用cookie存在客户端，而类似“express-session”的模块只在cookie中保存会话标识并将会话数据存在服务端。</p>
</blockquote>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>引入和配置：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> cookieSession = require(<span class="hljs-symbol">'cookie</span>-session’);<br>app.<span class="hljs-keyword">use</span>(cookieSession(&#123;<br>    name: <span class="hljs-symbol">'token</span>',<br>    keys: [<span class="hljs-symbol">'why</span>’],<br>    signed: <span class="hljs-literal">false</span><br>&#125;));<br></code></pre></td></tr></table></figure>
<p>cookie-session用法与express-session保持着高度的相似性，也通过req.session存取会话数据：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">req.session.userid</span> = req.body.userid<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>cookie-session在浏览器种了cookie：</p>
<p><img src="http://static.chiyuanyuan.com/578DAE84-1B28-4A5B-9C61-209F3638D558.png" alt=""></p>
<h4 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h4><p><img src="http://static.chiyuanyuan.com/8E03B580-1918-4D5A-B263-28360D65EC5A.png" alt=""></p>
<p>cookie-session封装了cookie和req.session间存取的编解码过程，其实就是base64：    </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">比如cookie值：<span class="hljs-attribute">eyJ1c2VyaWQiOiJhIn0</span>=，base64解码后就是JSON：&#123;<span class="hljs-string">"userid"</span>:<span class="hljs-string">"abb”&#125;。</span><br></code></pre></td></tr></table></figure>
<h4 id="防篡改"><a href="#防篡改" class="headerlink" title="防篡改"></a>防篡改</h4><p>如果把signed配置为true，就多一个.sig cookie，签名防篡改。这个是由依赖模块实现的：<a href="https://github.com/crypto-utils/keygrip" target="_blank" rel="noopener">https://github.com/crypto-utils/keygrip</a><br>这个.sig的值固定长度27位，是token值经过带密钥（key）哈希（SHA1算法）后获得的。</p>
<h3 id="token实现之二：JWT"><a href="#token实现之二：JWT" class="headerlink" title="token实现之二：JWT"></a>token实现之二：JWT</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>JSON Web Tokens，简称JWT，是签发/验证Token的一个标准。JWT生成的token具备固定格式和可验证能力。</p>
<h4 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h4><p>一个JWT签发的token实例如下：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">eyJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiIsInR5</span>cCI<span class="hljs-number">6</span>IkpX<span class="hljs-attr">VCJ9</span>.eyJ<span class="hljs-number">1</span>c<span class="hljs-number">2</span>VyaWQiOiJhIiwiaWF<span class="hljs-number">0</span>Ijox<span class="hljs-symbol">NTUxOTUxOTk4</span>fQ<span class="hljs-number">.2</span>jf<span class="hljs-number">3</span>kl_uKWRkwjOP<span class="hljs-number">6</span>uQRJFqMlwSABcgqqcJofFH<span class="hljs-number">5</span>XCo<br></code></pre></td></tr></table></figure>
<p>其中通过“.”分割为三个部分：</p>
<ul>
<li>header</li>
<li>payload</li>
<li>sigrature</li>
</ul>
<h5 id="header"><a href="#header" class="headerlink" title="header"></a>header</h5><figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">eyJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiIsInR5</span>cCI<span class="hljs-number">6</span>IkpX<span class="hljs-attr">VCJ9</span><br></code></pre></td></tr></table></figure>
<p>解码后</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"alg"</span>:<span class="hljs-string">"HS256"</span>,<span class="hljs-attr">"typ"</span>:<span class="hljs-string">"JWT"</span>&#125;<br></code></pre></td></tr></table></figure>
<p>是一个JSON对象，记录JWT的一些元数据。alg是一个必须参数，表示加密算法。</p>
<h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">eyJ<span class="hljs-number">1</span>c<span class="hljs-number">2</span>VyaWQiOiJhIiwiaWF<span class="hljs-number">0</span>Ijox<span class="hljs-symbol">NTUxOTUxOTk4</span>fQ<br></code></pre></td></tr></table></figure>
<p>解码后</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">"userid"</span>:<span class="hljs-string">"a"</span>,<span class="hljs-attr">"iat"</span>:<span class="hljs-number">1551951998</span>&#125;<br></code></pre></td></tr></table></figure>
<p>也是一个JSON对象，其中一部分是JWT自身的信息，可能包括：</p>
<ul>
<li>iss：Issuer，发行者</li>
<li>sub：Subject，主题</li>
<li>aud：Audience，观众</li>
<li>exp：Expiration time，过期时间</li>
<li>nbf：Not before</li>
<li>iat：Issued at，发行时间</li>
<li>jti：JWT ID</li>
</ul>
<p>另一部分是自定义的数据，比如这里的userid。</p>
<h5 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">2</span>jf3kl_uKWRkwjOP6uQRJFqMlwSABcgqqcJofFH5XCo<br></code></pre></td></tr></table></figure>

<p>解码后是乱码，这部分是给钱两部分的签名，具体算法如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><code class="hljs lisp">const encodedString = base64UrlEncode(<span class="hljs-name">header</span>) + <span class="hljs-string">"."</span> + base64UrlEncode(<span class="hljs-name">payload</span>)<span class="hljs-comment">; </span><br>HMACSHA256(<span class="hljs-name">encodedString</span>, 'why')<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>其中“why”为密钥，由服务端自己约定和记录。</p>
<h4 id="JWT签发"><a href="#JWT签发" class="headerlink" title="JWT签发"></a>JWT签发</h4><p>这个jsonwebtoken库实现了jwt：<a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="noopener">https://www.npmjs.com/package/jsonwebtoken</a></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jsonwebtoken'</span>)<br><span class="hljs-keyword">const</span> payload = &#123;<br>  userid: ‘a<span class="hljs-string">'<br>&#125;<br>const secret = ‘why'</span><br><span class="hljs-keyword">const</span> token = jwt.sign(payload, secret, &#123; expiresIn: <span class="hljs-string">'1day'</span> &#125;)<br><span class="hljs-built_in">console</span>.log(token)<br></code></pre></td></tr></table></figure>

<h4 id="JWT验证"><a href="#JWT验证" class="headerlink" title="JWT验证"></a>JWT验证</h4><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">jwt.verify(<span class="hljs-keyword">token</span>, ‘why', (<span class="hljs-keyword">error</span>, decoded) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span>) &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">error</span>.message)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  console.<span class="hljs-built_in">log</span>(decoded)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="express-jwt"><a href="#express-jwt" class="headerlink" title="express-jwt"></a>express-jwt</h4><p>在express下，还可以用这个：<a href="https://www.npmjs.com/package/express-jwt" target="_blank" rel="noopener">https://www.npmjs.com/package/express-jwt</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> jwt = <span class="hljs-keyword">require</span>(<span class="hljs-string">'express-jwt'</span>);<br> <br>app.<span class="hljs-keyword">use</span>(<span class="hljs-title">jwt</span>(&#123;<br>    <span class="hljs-title">secret</span>: '<span class="hljs-title">why</span>’<br>&#125;));<br></code></pre></td></tr></table></figure>

<p>jwt的payload会被挂在req.user上</p>
<h3 id="Token过期和Refresh-Token"><a href="#Token过期和Refresh-Token" class="headerlink" title="Token过期和Refresh Token"></a>Token过期和Refresh Token</h3><h4 id="Token过期"><a href="#Token过期" class="headerlink" title="Token过期"></a>Token过期</h4><p>相比session-cookie，token包含的信息更多，一个过期时间就更加必要。token过期后，需要重新获取授权。考虑两种场景：</p>
<ul>
<li>如果只是简单的维持登录状态，可以给token一个相对长的过期时间，过期后用户重新登录。</li>
<li>如果token用来访问某些敏感资源，过期时间就必须较短，反复授权体验会很差。<br>针对第二个情况，一种解决方案就是提供refresh token。</li>
</ul>
<h4 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h4><p>Refresh Token是用来获取Token的，把用户鉴权和敏感资源鉴权分开。如下盗图：</p>
<p><img src="http://static.chiyuanyuan.com/CAC63143-5E71-4003-8C28-0478A2B69283.png" alt=""></p>
<p>客户端认证用户后，会获得一个Refresh Token，只包含用户相关信息，只有获取Token的权限，所以过期时间较长。</p>
<p>通过Refresh Token去获取访问资源的Access Token，权限较重，过期时间较短。</p>
<p>当Access Token过期，只要通过Refresh Token重新获取。</p>
<h3 id="和cookie-session相比"><a href="#和cookie-session相比" class="headerlink" title="和cookie-session相比"></a>和cookie-session相比</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul>
<li>客户端适用范围更广</li>
<li>鉴权参数存储、传递的方式更丰富</li>
<li>可以避免CSRF</li>
<li>【但】鉴权字符串会变大</li>
</ul>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul>
<li>免存储，解放了服务器存储和扩展能力</li>
<li>【但】增加了每次请求的运算压力（时间换空间）</li>
</ul>

  </div>
</section>

  




    </div>
  </div>
</body>
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="/js/script.js"></script>

</html>